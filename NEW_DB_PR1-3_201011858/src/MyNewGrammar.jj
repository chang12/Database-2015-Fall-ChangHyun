options{  static = true;  DEBUG_PARSER = false;}PARSER_BEGIN(SimpleDBMSParser)import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Arrays;// Import libraries from Berkeley DB
import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.Cursor;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;public class SimpleDBMSParser{  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_INSERT = 4;  public static String errorMsg;  public static String currentTableName;  public static EnvironmentConfig envConfig;  public static Environment myDbEnvironment = null;  public static DatabaseConfig dbConfig;  public static Database myDatabase = null;  public static boolean error = false;  public static void main(String args []) throws ParseException  {    /* OPENING DB Environment */    // Open Database Environment or if not, create one.
    envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDbEnvironment = new Environment(new File("db/"), envConfig);    // Set database configuration
    dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(false);    /* DB Setting Finished */    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    while (true)    {      try      {        System.out.print("DB_2010-11858> ");        parser.command();      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }  }  public static void printMessage(int q)  {    switch (q)    {      case PRINT_SYNTAX_ERROR :       // query processing 도중에 syntax error가 발생한 경우, currentTableName이 저장되어 있는 상태다.
      // 무효한 table이므로 remove 해주고, syntax error 메시지를 출력한다.
      if (!currentTableName.equals(""))      {        myDbEnvironment.removeDatabase(null, currentTableName);      }      System.out.println("Syntax error");      break;      case PRINT_CREATE_TABLE :       // errorMsg가 공란이 아니라는 것은, create table query의 grammar는 맞았지만 semantic 오류가 있다는 뜻이다.
      // semantic 오류가 있었다면, table 이름은 @TEMP로 rename 되어있을 것이다.
      // 그러므로 @TEMP 이름의 table을 remove 해준다.   
      if (errorMsg.equals(""))      {        putKeyValue("@TABLELIST", currentTableName, currentTableName);        System.out.println("\'" + currentTableName + "\' table is created");      }      else      {        System.out.println(errorMsg);        myDbEnvironment.removeDatabase(null, "@TEMP");      }      break;      case PRINT_DROP_TABLE :       break;      case PRINT_DESC :       break;      case PRINT_INSERT :      if(errorMsg.length()==0) System.out.println("\'INSERT\' requested");      else System.out.println(errorMsg);      break;    }  }  // dbName의 database를 열어서, keyString을 key로 하는 key-value pair가 있는지를 True/False로 반환한다.
  static public boolean findKeyValue(String dbName, String keyString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry foundKey;    DatabaseEntry foundValue;    boolean result = false;    try    {      foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));      foundValue = new DatabaseEntry();      if (cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS)      {        result = true;      }      else      {        result = false;      }    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();    return result;  }  // dbName의 database에 <keyString, valueString >의 pair를 넣는다.
  static public void putKeyValue(String dbName, String keyString, String valueString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry key;    DatabaseEntry value;    try    {      key = new DatabaseEntry(keyString.getBytes("UTF-8"));      value = new DatabaseEntry(valueString.getBytes("UTF-8"));      cursor.put(key, value);    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();  }  // dbName의 테이블에서, keyString으로 key-value pair를 찾아 value를 반환한다.
  static public String getValue(String dbName, String keyString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry foundKey;    DatabaseEntry foundValue;    String result = "";    try    {      foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));      foundValue = new DatabaseEntry();      if (cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS)      {        result = new String(foundValue.getData(), "UTF-8");      }      else      {        result = "";      }    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();    return result;  }  // dbName의 database를 열어서, keyString으로 key-value pair를 찾고 해당 pair를 삭제한다.
  static public void deleteKeyValue(String dbName, String keyString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry foundKey;    DatabaseEntry foundValue;    try    {      foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));      foundValue = new DatabaseEntry();      if (cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS)      {        cursor.delete();      }    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();  }  // keyList로 받은 String은 여러 String 들이 " "로 구분되어있는 String 이다.
  // keyArray의 원소들 중, dbName 이름의 database에 존재하지 않은 key가 있는지 찾는다.
  // 하나라도 존재하지 않으면 false를 반환한다. 
  static public boolean keyListValidation(String dbName, String keyList, int addMsg)  {    String key;    String [] keyArray = keyList.split(" ");    int keyArrayLength = keyArray.length;    boolean result = true;    for (int i = 0; i < keyArrayLength; i++)    {      key = keyArray [i];      if (!findKeyValue(dbName, key))      {        result = false;        if (addMsg == 1) addErrorMsg("Create table has failed: \'" + key + "\' does not exists in column definition");        else if (addMsg == 2) addErrorMsg("Insertion has failed: \'" + key + "\' does not exist");        break;      }    }    return result;  }  // explicit한 primary key / foreign key 정의가 없을 때, table을 규격에 맞추기 위해 호출한다.
  static public void setDefaultPkFk(String dbName)  {    if (!findKeyValue(dbName, "@PK"))    {      // create table query 내에 primary key 정의가 없는 경우이다.
      Cursor cursor = null;      myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);      cursor = myDatabase.openCursor(null, null);      String totalKeyList = "";      DatabaseEntry foundKey = new DatabaseEntry();      DatabaseEntry foundValue = new DatabaseEntry();      cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);      do      {        // table의 모든 key 값들을 순회하며, attribute에 PRI 속성을 부여한다. 
        try        {          String keyString = new String(foundKey.getData(), "UTF-8");          String valueString = new String(foundValue.getData(), "UTF-8");          // key 값들 중 @PK, @REFER, @REFERED 같은 애들은 건드리지 않기 위해 첫글자와 @를 비교한다.
          if (!keyString.substring(0, 1).equals("@"))          {            String [] valueArray = valueString.split(" ");            // Attribute의 key-value pair에서 value는 "TYPE SIZE NULL ..." 의 양식을 따르므로,
            // Split 후 3번째 원소가 nullable에 대한 Y/N 값이다.
            // Primary key 를 이루는 attribute이므로 N으로 설정한다.
            valueArray [2] = "N";            // 새로운 value string 을 newValueString 이라는 이름으로 만든다.
            String newValueString = "";            for (int j = 0; j < valueArray.length; j++)            {              newValueString += (valueArray [j] + " ");            }            // 끝에 "PRI"를 붙인다.
            newValueString += "PRI";            // foundValue DatabaseEntry를 수정하고, table에 put.
            foundValue.setData(newValueString.getBytes());            cursor.put(foundKey, foundValue);            totalKeyList += (keyString + " ");          }        }        catch (UnsupportedEncodingException e)        {          e.printStackTrace();        }      }      while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);      // @PK 값에는 primary key를 이루는 attribute set이 "attr1 attr2 ... attrn"처럼 " "으로 구분되어 합쳐져있다.
      // 이를 @PK 를 key 로 하는 pair를 만들어 table에 넣는다.
      totalKeyList = totalKeyList.substring(0, totalKeyList.length() - 1);      cursor.close();      myDatabase.close();      putKeyValue(dbName, "@PK", totalKeyList);    }    // @REFER, @REFERED 의 값이 없다면 만들어준다.
    if (!findKeyValue(dbName, "@REFER")) putKeyValue(dbName, "@REFER", "");    putKeyValue(dbName, "@REFERED", "");  }  // 참조받는 Table의 primary key와 참조하는 column set이 일치해야한다.
  // String array comparison을 이용해서 쉽게 구현.
  static public boolean referencePkValidation(String dbName, String keyList)  {    boolean result = false;    String primaryKey = getValue(dbName, "@PK");    String [] primaryKeyArray = primaryKey.split(" ");    String [] keyArray = keyList.split(" ");    if (keyArray.length == primaryKeyArray.length)    {      // 정확한 비교를 위해 우선 sorting
      Arrays.sort(keyArray);      Arrays.sort(primaryKeyArray);      if (Arrays.equals(keyArray, primaryKeyArray)) result = true;    }    return result;  }  // 참조받는 column set과 참조하는 column set의 type 및 size가 일치하는지 확인한다.
  // 일치하면 true, 아니면 false를 반환한다.
  static public boolean referenceDataTypeValidation(String dbName1, String keyList1, String dbName2, String keyList2)  {    boolean result = true;    String [] keyArray1 = keyList1.split(" ");    String [] keyArray2 = keyList2.split(" ");    // 우선 column set의 크기가 같아야 한다.
    if (keyArray1.length == keyArray2.length)    {      for (int i = 0; i < keyArray1.length; i++)      {        // "TYPE SIZE ..."로 구성되므로, [0]: int/char/date [1]: size
        // 두 가지를 체크해준다.
        String [] attrDataType1 = getValue(dbName1, keyArray1 [i]).split(" ");        String [] attrDataType2 = getValue(dbName2, keyArray2 [i]).split(" ");        boolean typeMatch = attrDataType1 [0].equals(attrDataType2 [0]);        boolean sizeMatch = attrDataType1 [1].equals(attrDataType2 [1]);        if (!(typeMatch && sizeMatch))        {          result = false;          break;        }      }    }    else    {      result = false;    }    return result;  }  // explicit 한 primary key declaration이 있는 경우에는,
  // 해당 columns 들은 무조건 not nullable 로 지정하고, 
  // 해당 columns 들만 "PRI" 속성을 부여하기 위해 value 값에 뒤에 "PRI"를 덧붙인다.
  static public void addPrimaryKey(String dbName, String columnNameList)  {    String [] columnNameArray = columnNameList.split(" ");    Arrays.sort(columnNameArray);    for (int i = 0; i < columnNameArray.length; i++)    {      String valueString = getValue(dbName, columnNameArray [i]);      String [] valueArray = valueString.split(" ");      valueArray [2] = "N";      valueString = "";      for (int j = 0; j < valueArray.length; j++)      {        valueString += (valueArray [j] + " ");      }      valueString += "PRI";      putKeyValue(dbName, columnNameArray [i], valueString);    }    putKeyValue(dbName, "@PK", columnNameList);  }  // reference 가 declaration된 경우,
  // 참조하는 columns들의 key-value pair에서 value 뒤에 "FOR"을 덧붙이고,
  // 참조하는 table의 @REFER key 값의 value를 갱신하고,
  // 참조받는 table의 @REFERED key 값의 value를 갱신한다.
  static public void addForeignKey(String referencingTable, String columnNameList, String referencedTable)  {    String currentRefered = getValue(referencedTable, "@REFERED");    currentRefered += (referencingTable + " ");    putKeyValue(referencedTable, "@REFERED", currentRefered);    String currentRefer = getValue(referencingTable, "@REFER");    currentRefer += (referencedTable + " ");    putKeyValue(referencingTable, "@REFER", currentRefer);    String [] columnNameArray = columnNameList.split(" ");    for (int i = 0; i < columnNameArray.length; i++)    {      String currentDataType = getValue(referencingTable, columnNameArray [i]);      String updatedDataType = currentDataType + " FOR";      putKeyValue(referencingTable, columnNameArray [i], updatedDataType);    }  }  // table1, table2, table3 ...로 요청된 table list들의 desc를 수행한다.
  // * 이 요청된 경우 모두 출력해주고,
  // table1, table2, ... 로 요청된 경우 우선 존재하는 table인지를 체크하고 모두 존재한다면 출력한다.
  static public void descTableList(String dbNameList)  {    if (dbNameList.equals("*"))    {      // totalTableList: "table1 table2 table3 ..."
      String totalTableList = getValue("@TABLELIST", "@ALL");      if (!totalTableList.equals(""))      {        String [] totalTableArray = totalTableList.split(" ");        System.out.println("---------------------------------------------");        for (int i = 0; i < totalTableArray.length; i++)        {          descTable(totalTableArray [i]);        }      }    }    else    {      String [] dbNameArray = dbNameList.split(" ");      boolean isError = false;      for (int i = 0; i < dbNameArray.length; i++)      {        // @TABLELIST에 존재하는 key 값이 아니라는 얘기는, 존재하지 않는 table이라는 의미이므로 error 발생이다.
        if (!findKeyValue("@TABLELIST", dbNameArray [i]))        {          isError = true;          break;        }      }      if (!isError)      {        System.out.println("---------------------------------------------");        for (int i = 0; i < dbNameArray.length; i++)        {          descTable(dbNameArray [i]);        }      }      else      {        System.out.println("No such table");      }    }  }  // 단일 table 출력을 담당.
  // destTableList에서 호출된다.
  static public void descTable(String dbName)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry foundKey = new DatabaseEntry();    DatabaseEntry foundValue = new DatabaseEntry();    // table에는 @PK, @REFER, @REFERED 의 key를 가지고 있다.
    // key들이 alphabetically ordered 되어있으므로, 첫 3개가 쟤네들에 해당.
    // 그러므로 desc 에서 저 3개를 건너뛰고 시작한다.
    cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);    System.out.println("table_name [" + dbName + "]");    System.out.println("column_name\ttype\tnull\tkey");    do    {      try      {        String keyString = new String(foundKey.getData(), "UTF-8");        if(!keyString.contains("@"))        {          String valueString = new String(foundValue.getData(), "UTF-8");          String [] valueArray = valueString.split(" ");          // char인 경우 size가 의미가 있고,          // int / date의 경우 그냥 size를 0으로 해놨고 의미가 없으니 안써야한다.          if (valueArray [0].equals("char"))          {            System.out.print(keyString + "\tchar(" + valueArray [1] + ")\t" + valueArray [2] + "\t");          }          else          {            System.out.print(keyString + "\t" + valueArray [0] + "\t" + valueArray [2] + "\t");          }          switch (valueArray.length)          {            // 아무 key도 아님            case 3 : System.out.println("");            break;            // PRI or FOR            case 4 : System.out.println(valueArray [3]);            break;            // PRI and FOR            case 5 : System.out.println(valueArray [3] + "\t" + valueArray [4]);            break;          }        }      }      catch (UnsupportedEncodingException e)      {        e.printStackTrace();        System.out.println(e.getMessage());      }    }    while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);    System.out.println("---------------------------------------------");    cursor.close();    myDatabase.close();  }  static public void dropTable(String dbName)  {    if (dbName.equals("*"))    {      String totalTableList = getValue("@TABLELIST", "@ALL");      if (!totalTableList.equals(""))      {        String [] totalTableArray = totalTableList.split(" ");        for (int i = 0; i < totalTableArray.length; i++)        {          myDbEnvironment.removeDatabase(null, totalTableArray [i]);        }        myDbEnvironment.removeDatabase(null, "@TABLELIST");      }      System.out.println("Every table is dropped");    }    else    {      String [] dbNameArray = dbName.split(" ");      for (int i = 0; i < dbNameArray.length; i++)      {        if (findKeyValue("@TABLELIST", dbNameArray [i]))        {          // @REFERED 는 자신을 참조하는 Table 정보.
          // 그러므로 @REFERED가 ""가 아니고 값이 있으면 drop 하지말아야 한다.
          if (!getValue(dbNameArray [i], "@REFERED").equals(""))          {            System.out.println("Drop table has failed: '" + dbNameArray [i] + "'is referenced by other table");          }          else          {            // @REFER는 내가 참조하는 테이블 정보.
            // 그러므로 나를 Drop table 하면서, 내가 참조하는 테이블들의 @REFERED 에서 내 이름을 뺀다.
            if (!getValue(dbNameArray [i], "@REFER").equals(""))            {              String referedList = getValue(dbNameArray [i], "@REFER");              String [] referedArray = referedList.split(" ");              for (int j = 0; j < referedArray.length; j++)              {                // "table1 table2 ... tablen" 에서 table2를 지워 "table1 ... tablen" 으로 만드는 것같은 상황을 처리.
                deletePartialValue(referedArray [j], "@REFERED", dbNameArray [i]);              }            }            myDbEnvironment.removeDatabase(null, dbNameArray [i]);            // @TABLELIST 에서 <tablename, "column1 column2 ... columnn" > pair를 삭제            
            deleteKeyValue("@TABLELIST", dbNameArray [i]);            // @TABLELIST 의 @ALL 값이 "table1 table2 table3 ..." 인데,
            // drop한 table을 빼준다.
            deletePartialValue("@TABLELIST", "@ALL", dbNameArray [i]);            System.out.println("'" + dbNameArray [i] + "' table is dropped");          }        }        else        {          System.out.println("No such table named '" + dbNameArray [i] + "'");        }      }    }  }  static public void addErrorMsg(String msg)  {    // 첫 error messsge만 출력하기 위함.
    if (errorMsg.equals(""))    {      errorMsg = msg;    }  }  static public void addTableName(String tableName)  {    if (!tableName.equals("@TEMP"))    {      // @ALL 뒤에 table name을 덧붙인다.
      String currentTableNameList = getValue("@TABLELIST", "@ALL");      String newTableNameList = currentTableNameList + tableName + " ";      putKeyValue("@TABLELIST", "@ALL", newTableNameList);    }  }  // "value1 value2 value3 ..." 에서 value2를 지운다면 "value1 value3 ..."가 된다.
  // 해당 작업을 위한 함수.
  static public void deletePartialValue(String dbName, String keyString, String valueToDelete)  {    String valueList = getValue(dbName, keyString);    String [] valueArray = valueList.split(" ");    int i;    for (i = 0; i < valueArray.length; i++)    {      if (valueArray [i].equals(valueToDelete)) break;    }    if (i != valueArray.length)    {      valueArray [i] = "";      String newValueList = "";      for (int j = 0; j < valueArray.length; j++)      {        newValueList += (valueArray [j] + " ");      }      newValueList = newValueList.substring(0, newValueList.length() - 1);      putKeyValue(dbName, keyString, newValueList);    }  }  static public String[] insertTypeCheck(String dbName, String[] columnArray, String[] valueArray)  {    int length = columnArray.length;    int i = 0;    while(i<=length-1)    {      String desc = getValue(dbName, columnArray[i]);      switch(valueArray[i].split(" ")[0])      {        case "int":        	System.out.println("int case");        	if(!desc.split(" ")[0].equals("int"))        	{        	  error = true;        	  addErrorMsg("Insertion has failed: Types are not matched.");        	}        	break;        case "char":        	System.out.println("char case");        	if(!desc.split(" ")[0].equals("char"))        	{        	  error = true;        	  addErrorMsg("Insertion has failed: Types are not matched.");        	}        	else if(Integer.parseInt(desc.split(" ")[1])<valueArray[i].split(" ")[1].length())        	{        	  valueArray[i] = "char "+valueArray[i].split(" ")[1].substring(0, Integer.parseInt(desc.split(" ")[1])-1);        	}        	break;        case "date":        	System.out.println("date case");        	if(!desc.split(" ")[0].equals("date"))        	{        	  error = true;        	  addErrorMsg("Insertion has failed: Types are not matched.");        	}        	break;        case "null":        	System.out.println("null case");        	if(!desc.split(" ")[2].equals("Y"))        	{        	  error = true;        	  addErrorMsg("Insertion has failed: '"+columnArray[i]+"' is not nullable");        	}      }      if(error) break;      i++;    }    return valueArray;  } }PARSER_END(SimpleDBMSParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < INSERT_INTO : "insert into" >| < VALUES : "values" >| < NULL : "null" >| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >}TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < SIGN :    "+"  | "-" >| < STAR : "*" >| < INT_VALUE : (< SIGN >)? ([ "0"-"9" ])+ >| < LEGAL_IDENTIFIER :    < ALPHABET >    (      < ALPHABET >    | < UNDERSCORE >    )* >| < ALPHABET : [ "A"-"Z", "a"-"z" ] >| < DIGIT : [ "0"-"9" ] >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE >>| < QUOTE : "\'" >| < SPACE : (" ")+ >| < NON_QUOTE_CHARACTER :    < DIGIT >  | < ALPHABET >  | < NON_QUOTE_SPECIAL_CHARACTERS >  | < SPACE >>| < NON_QUOTE_SPECIAL_CHARACTERS :    "!"  | "@"  | "#"  | "$"  | "%"  | "^"  | "&"  | "*"  | "("  | ")"  | "-"  | "_"  | "+"  | "["  | "]"  | "|"  | ":"  | ";"  | "<"  | ">"  | "?"  | "/"  | "."  | "," >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN >>| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT >>| < NN : < DIGIT > < DIGIT >>}void command() :{}{  queryList()|  (    < EXIT >     < SEMICOLON >    {      if (myDatabase != null) myDatabase.close();      if (myDbEnvironment != null) myDbEnvironment.close();      System.exit(0);    }  )}void queryList() :{  int q;}{  (    q = query()     < SEMICOLON >    {      System.out.print("DB_2010-11858> ");      printMessage(q);    }  )+}int query() :{  int q;  currentTableName = "";  errorMsg = "";}{  (    createTableQuery()    {      q = PRINT_CREATE_TABLE;    }  | dropTableQuery()    {      q = PRINT_DROP_TABLE;    }  | descQuery()    {      q = PRINT_DESC;    }  | insertQuery()  	{  	  q = PRINT_INSERT;  	}  )  (  {    return q;  }  )}void createTableQuery() :{  String tableName;}{  < CREATE_TABLE >   tableName = tableName()  {    // @TABLELIST에 존재하는 key라는 것은 이미 tableNAME의 table이 존재한다는 것
    if (findKeyValue("@TABLELIST", tableName))    {      addErrorMsg("Create table has failed: table with the same name already exists");      currentTableName = "@TEMP";    }    else    {      currentTableName = tableName;      // 에러가 발생하지 않았다면, @COLUMN key를 가지고 pair 를 만들어 저장해나갈 것이다.
      // 현재는 비어있으므로 ""로 추가한다.
      putKeyValue(tableName, "@COLUMN", "");    }  }  tableElementList(tableName)  {    // create table query의 grammar가 모두 지켜진 경우 해당 작업을 수행한다.
    setDefaultPkFk(currentTableName);    addTableName(currentTableName);    // 디버깅
    System.out.println(getValue(currentTableName, "@COLUMN"));  }}void tableElementList(String tableName) :{}{  < LEFT_PAREN >   tableElement(tableName)  (    < COMMA >     tableElement(tableName)  )*  < RIGHT_PAREN >}void tableElement(String tableName) :{}{  columnDefinition(tableName)| tableConstraintDefinition(tableName)}void columnDefinition(String tableName) :{  String columnName;  String dataType;  String databaseName;  boolean result;}{  columnName = columnName()   dataType = dataType()  {    // example: "int 0 Y" "char 10 Y"
    dataType += " Y";  }  (    < NOT_NULL >    {      // example: "int 0 N" "char 10 N" 
      dataType = dataType.substring(0, dataType.length() - 1) + "N";    }  )?  {    // table에 이미 선언된 columnName인지 확인한다.
    if (findKeyValue(currentTableName, columnName))    {      addErrorMsg("Create table has failed: column definition is duplicated");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    else    {      // 컬럼 이름을 key로 하는 pair를 추가한다. data type에 대한 정보를 담고 있다.
      putKeyValue(currentTableName, columnName, dataType);      // @COLUMN key의 value에 해당 컬럼 이름을 추가한다.
      String temp = getValue(currentTableName, "@COLUMN");      temp += (columnName + " ");      putKeyValue(currentTableName, "@COLUMN", temp);    }  }}void tableConstraintDefinition(String tableName) :{}{  primaryKeyConstraint(tableName)| referentialConstraint(tableName)}void primaryKeyConstraint(String tableName) :{  String columnNameList;  String databaseName;}{  < PRIMARY_KEY >   columnNameList = columnNameList()  {    // primary key 정의가 이미 있었다면, @PK 를 key로 하는 pair가 존재할 것.
    if (findKeyValue(currentTableName, "@PK"))    {      addErrorMsg("Create table has failed: primary key definition is duplicated");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    else    {      // 정의된 columns들 가지고 primary key를 구성했는지 체크한다.
      if (keyListValidation(currentTableName, columnNameList, 1))      {        addPrimaryKey(currentTableName, columnNameList);      }      else      {        myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");        currentTableName = "@TEMP";      }    }  }}void referentialConstraint(String referencingTableName) :{  String referencingColumnNameList;  String referencedTableName;  String referencedColumnNameList;  String databaseName;}{  < FOREIGN_KEY >   referencingColumnNameList = columnNameList()  {    // 존재하는 columns 들 가지고 Foreign key를 구성했는지 체크한다.
    if (!keyListValidation(currentTableName, referencingColumnNameList, 1))    {      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }  }  < REFERENCES >   referencedTableName = tableName()  {    // 참조하려는 table이 존재하는 table인지 확인한다.
    if (!findKeyValue("@TABLELIST", referencedTableName))    {      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      addErrorMsg("Create table has failed: foreign key references non existing table");      currentTableName = "@TEMP";    }  }  referencedColumnNameList = columnNameList()  {    // 참조받을 columns들이 참조받을 table에 존재하는 columns들인가?
    if (!keyListValidation(referencedTableName, referencedColumnNameList, 0))    {      addErrorMsg("Create table has failed: foreign key references non existing column");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    // 참조받을 columns들이 primary key를 구성하는가?
    else if (!referencePkValidation(referencedTableName, referencedColumnNameList))    {      addErrorMsg("Create table has failed: foreign key references non primary key column");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    // 참조하려는 columns들과 참조받을 columns들의 type이 일치하는가?
    else if (!referenceDataTypeValidation(currentTableName, referencingColumnNameList, referencedTableName, referencedColumnNameList))    {      addErrorMsg("Create table has failed: foreign key references wrong type");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    if (!currentTableName.equals("@TEMP"))    {      addForeignKey(currentTableName, referencingColumnNameList, referencedTableName);    }  }}String columnNameList() :{  String columnNameList;  String columnName;}{  < LEFT_PAREN >   columnNameList = columnName()  (    < COMMA >     columnName = columnName()    {      columnNameList += (" " + columnName);    }  )*  < RIGHT_PAREN >  {    return columnNameList;  }}String dataType() :{  Token intValueToken;  int intValue;}{  < INT >  {    return "int 0";  }|  (    < CHAR >     < LEFT_PAREN >     intValueToken = < INT_VALUE >     < RIGHT_PAREN >    {      intValue = Integer.parseInt(intValueToken.image);      if (intValue < 1)      {        // char(0), char(-1) 같은 경우 에러 발생
        addErrorMsg("Char length should be > 0");        myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");        currentTableName = "@TEMP";      }      return ("char " + intValue);    }  )| < DATE >  {    return "date 0";  }}String tableNameList() :{  String tableNameList;  String tableName;}{  < STAR >  {    return "*";  }|  (    tableNameList = tableName()    (      < COMMA >       tableName = tableName()      {        tableNameList += (" " + tableName);      }    )*  )  {    return tableNameList;  }}String tableName() :{  Token tableName;}{  tableName = < LEGAL_IDENTIFIER >  {    return tableName.image.toLowerCase();  }}String columnName() :{  Token columnName;}{  columnName = < LEGAL_IDENTIFIER >  {    return columnName.image.toLowerCase();  }}void dropTableQuery() :{  String tableNameList;}{  < DROP_TABLE >  {    errorMsg = "";  }  tableNameList = tableNameList()  {    dropTable(tableNameList);  }}void descQuery() :{  String tableNameList;}{  < DESC >   tableNameList = tableNameList()  {    descTableList(tableNameList);  }}void insertQuery() :{  String tableName;}{  < INSERT_INTO >   tableName = tableName()  {    error = false;    // INSERT 하려는 테이블이 존재하는지 확인한다.
    // 존재하지 않는 테이블에 INSERT를 시도한다면 에러를 발생시켜야 한다.
    if (findKeyValue("@TABLELIST", tableName))    {      currentTableName = tableName;    }    else    {      addErrorMsg("No such table");      error = true;    }  }  insertColumnsAndSource()}void insertColumnsAndSource() :{  String columnNameList = "";}{  (    columnNameList = columnNameList()  )?  {    if (!error&&(columnNameList.length()>0))    {      // columnNameList와, 실제 테이블을 구성하는 컬럼들의 리스트를 비교한다.      System.out.println(getValue(currentTableName, "@COLUMN"));      System.out.println(currentTableName);
      String [ ] trueColumnNameArray = getValue(currentTableName, "@COLUMN").split(" ");      String [ ] columnNameArray = columnNameList.split(" ");      Arrays.sort(trueColumnNameArray);      Arrays.sort(columnNameArray);      // column 개수가 다르다면 에러이다.
      if (columnNameArray.length != trueColumnNameArray.length)      {        addErrorMsg("Insertion has failed: Number of columns are different.");        error = true;      }      // 존재하지 않는 컬럼에 INSERT 시도하면 에러이다.      else if (!keyListValidation(currentTableName, columnNameList, 2))      {        // 에러 메시지는 keyListValidation 메소드에서 출력해주었다
        error = true;      }      // 이 경우는 columnNameList의 duplicate 한 column name이 들어온 경우이다.      else if (!Arrays.equals(columnNameArray, trueColumnNameArray))      {
        addErrorMsg("Insertion has failed: Inserted columns must be distinct.");        error = true;      }    }  }  valueList(columnNameList)}void valueList(String columnNameList) :{  String value;  String[] columnArray = null;  String[] valueArray = null;  int length = 0;  int index = 0;}{  < VALUES >   < LEFT_PAREN >  {    // 이전에 에러가 발생하지 않은 경우에만 수행한다.    if(!error)    {      // column이 명시되지 않은 경우에는, create table 해서 생기는 순서로 (if)      // column이 명시된 경우에는, 받은 column 순서대로 (else)      if(columnNameList.length()==0) columnArray = getValue(currentTableName, "@COLUMN").split(" ");      else columnArray = columnNameList.split(" ");      // data type 비교를 위한 자료들을 준비해둔다      valueArray = new String[columnArray.length];      length = valueArray.length;     }  }   value = value()  {    if(!error)    {      index = 0;      valueArray[index] = value;    }  }  (    < COMMA >     value = value()    {      if(!error)      {        if(++index<=length-1) valueArray[index] = value;        else        {          addErrorMsg("Insertion has failed: Too many input values.");          error = true;        }      }    }  )*  < RIGHT_PAREN >  {    if(!error)    {      // 레코드의 컬럼 개수와, values로 받아온 컬럼 개수가 맞는지 체크한다.      if(index != length - 1)      {        addErrorMsg("Insertion has failed: Too few input values.");        error = true;      }      // come back      insertTypeCheck(currentTableName, columnArray, valueArray);    }  }}String value() :{  String result;}{  < NULL >  {    return "null";  }| result = comparableValue()  {    return result;  }}String comparableValue() :{  Token token;}{  token = < INT_VALUE >  {    int intval = Integer.parseInt(token.image);    return("int "+intval);  }| token = < CHAR_STRING >  {    return("char "+token.image);  }| token = < DATE_VALUE >  {    return("date "+token.image);  }}
