options
{
  static = true;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(SimpleDBMSParser)

import java.io.File;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;

// Import libraries from Berkeley DB
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

public class SimpleDBMSParser
{
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  
  public static final int PRINT_DESC = 3;

  public static String errorMsg;
  public static String currentTableName;

  public static Environment myDbEnvironment = null;
  public static EnvironmentConfig envConfig;
  public static Database myDatabase = null;
  public static DatabaseConfig dbConfig;
  
  public static void main(String args[]) throws ParseException
  {
    /* OPENING DB */

    // Open Database Environment or if not, create one.
	envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDbEnvironment = new Environment(new File("db/"), envConfig);

    // Set database configuration
	dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(false);
    
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);

    while (true)
    {
      try
      {
        System.out.print("DB_2010-11858> ");
        parser.command();
      }
      catch (Exception e)
      {
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
    }
  }

  public static void printMessage(int q)
  {
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
      	if(!currentTableName.equals("")) myDbEnvironment.removeDatabase(null, currentTableName);
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	if(errorMsg.equals(""))      	{
      	  putKeyValue("@TABLELIST", currentTableName, currentTableName);      	  System.out.println("\'"+currentTableName+"\' table is created");
      	}
      	else      	{
      	  System.out.println(errorMsg);
      	  myDbEnvironment.removeDatabase(null, "@TEMP");      	}
      	break;
      case PRINT_DESC:
      	break;
    }
  }

  static public boolean findKeyValue(String dbName, String keyString)
  {
    Cursor cursor = null;
    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);
    cursor = myDatabase.openCursor(null, null);

	DatabaseEntry foundKey;
	DatabaseEntry foundValue;

	boolean result = false;
			
	try{
		foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));
		foundValue = new DatabaseEntry();

		if(cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT)==OperationStatus.SUCCESS){
		  result = true;
		}
		else{
		  result = false;
		}
		
	} catch(DatabaseException de){
		de.printStackTrace();
	} catch(UnsupportedEncodingException e){
		e.printStackTrace();
	}

	cursor.close();
	myDatabase.close();
	return result;  }
  
  static public void putKeyValue(String dbName, String keyString, String valueString)
  {
    Cursor cursor = null;
    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);
    cursor = myDatabase.openCursor(null, null);
		
	DatabaseEntry key;
	DatabaseEntry value;
		
	boolean result = false;
			
	try{
	  key = new DatabaseEntry(keyString.getBytes("UTF-8"));
	  value = new DatabaseEntry(valueString.getBytes("UTF-8"));
	  cursor.put(key, value);
		
	} catch(DatabaseException de){
	  de.printStackTrace();
	} catch(UnsupportedEncodingException e){
	  e.printStackTrace();
	}

	cursor.close();
	myDatabase.close();
  }

  static public boolean keyListValidation(String dbName, String keyList, boolean addMsg)
  {
    String key;
    String[] keyArray = keyList.split(" ");
    int keyArrayLength = keyArray.length;
    boolean result = true;

    for(int i=0;i<keyArrayLength;i++)    {
      key = keyArray[i];
      if(!findKeyValue(dbName, key))
      {
        result = false;
        if(addMsg) addErrorMsg("Create table has failed: \'"+key+"\' does not exists in column definition");
        break;      }    }
    
    return result;  }

  static public void setDefaultPk(String dbName)
  {
    if(findKeyValue(dbName, "@PK"))
    {
      ;    }
    else    {
      Cursor cursor = null;
      myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);
      cursor = myDatabase.openCursor(null, null);
       
      String totalKeyList = "";

      DatabaseEntry foundKey = new DatabaseEntry();
      DatabaseEntry foundValue = new DatabaseEntry();

      cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);

      do
      {
        try {
          String keyString = new String(foundKey.getData(), "UTF-8");
          String valueString = new String(foundValue.getData(), "UTF-8");

          totalKeyList += (keyString+" ");
          
        } catch(UnsupportedEncodingException e){
          e.printStackTrace();        }
      } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);

      totalKeyList = totalKeyList.substring(0, totalKeyList.length()-1);
      
      cursor.close();
      myDatabase.close();

      putKeyValue(dbName, "@PK", totalKeyList);
          }  }

  static public boolean foreignKeyValidation(String dbName, String keyList)
  {
    Cursor cursor = null;
    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);
    cursor = myDatabase.openCursor(null, null);

    DatabaseEntry foundKey;
	DatabaseEntry foundValue;

	String[] keyArray = keyList.split(" ");

	boolean result = false;
			
	try{
	  foundKey = new DatabaseEntry("@PK".getBytes("UTF-8"));
	  foundValue = new DatabaseEntry();

	  cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT).toString();
	  String primaryKey = new String(foundValue.getData(), "UTF-8");
	  String[] primaryKeyArray = primaryKey.split(" ");

	  if(keyArray.length==primaryKeyArray.length)
	  {
	    Arrays.sort(keyArray);
	    Arrays.sort(primaryKeyArray);
	    if(Arrays.equals(keyArray, primaryKeyArray)) result = true;
	  }
	} catch(DatabaseException de){
		de.printStackTrace();
	} catch(UnsupportedEncodingException e){
		e.printStackTrace();
	}

	cursor.close();
	myDatabase.close();
	return result;  }

  static public void deletePair(String tableName)
  {
    Cursor cursor = null;
    cursor = myDatabase.openCursor(null, null);

    DatabaseEntry foundKey = new DatabaseEntry();
    DatabaseEntry foundValue = new DatabaseEntry();

    cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);

    do    {
      try {
        String keyString = new String(foundKey.getData(), "UTF-8");
      	String valueString = new String(foundValue.getData(), "UTF-8");

      	if (keyString.split(" ")[0].equals(tableName))
      	{
      	  cursor.delete();
      	}      } catch(UnsupportedEncodingException e){
        e.printStackTrace();      }
    } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);  }

  static public void descTable(String dbName)
  {
    Cursor cursor = null;
    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);
    cursor = myDatabase.openCursor(null, null);

    DatabaseEntry foundKey = new DatabaseEntry();
    DatabaseEntry foundValue = new DatabaseEntry();

    cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);

    System.out.println("desc table "+dbName+": ");
    do
    {
      try {
        String keyString = new String(foundKey.getData(), "UTF-8");
      	String valueString = new String(foundValue.getData(), "UTF-8");
      	System.out.println(keyString+": "+valueString);
      } catch(UnsupportedEncodingException e){
        e.printStackTrace();
      }

    } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);
    
    cursor.close();
    myDatabase.close();  }

  static public void addErrorMsg(String msg)
  {
    if(errorMsg.equals(""))
    {
      errorMsg = msg;    }  }

}

PARSER_END(SimpleDBMSParser)

SKIP : { " " | "\r" | "\t" | "\n" }

TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE_TABLE : "create table" >
| < DESC : "desc" >
| < NOT_NULL : "not null" >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
}

TOKEN :
{
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < UNDERSCORE : "_" >
| < SIGN : "+" | "-" >
| < INT_VALUE : (< SIGN >)? (["0"-"9"])+ >
| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >
| < ALPHABET : [ "A"-"Z", "a"-"z" ] >
}

void command() :
{}
{
  queryList()
| (
    < EXIT >
    < SEMICOLON >
    {
      if (myDatabase != null) myDatabase.close();
      if (myDbEnvironment != null) myDbEnvironment.close();
      System.exit(0);
    }
  ) 
}

void queryList() :
{
  int q;
}
{
  (
    q = query()
    < SEMICOLON >
    {
      System.out.print("DB_2010-11858> ");
      printMessage(q);
    }
  )+
}

int query() :
{
  int q;
}
{
  (
    createTableQuery()
    {
      q = PRINT_CREATE_TABLE;    }
  | descQuery()
    {
      q = PRINT_DESC;    }
  )
  (
    {
      return q;
    }
  )
}

void createTableQuery() :
{
  String tableName;
}
{
  < CREATE_TABLE >
  tableName = tableName()
  {
    errorMsg = "";
    currentTableName = "";    if(findKeyValue("@TABLELIST", tableName))    {      addErrorMsg("Create table has failed: table with the same name already exists");      currentTableName = "@TEMP";    }    else    {      currentTableName = tableName;    }  }
  tableElementList(tableName)
  {
    setDefaultPk(currentTableName);  }
}

void tableElementList(String tableName) :
{}
{
  < LEFT_PAREN >
  tableElement(tableName)
  (
    < COMMA >
    tableElement(tableName)
  )*
  < RIGHT_PAREN >
}

void tableElement(String tableName) :
{}
{
  columnDefinition(tableName)
| tableConstraintDefinition(tableName)
}

void columnDefinition(String tableName) :
{
  String columnName;
  String dataType;
  String databaseName;

  boolean result;
}
{
  columnName = columnName()
  dataType = dataType()
  {
    dataType += " Y";  }
  (
    < NOT_NULL >
    {
      dataType = dataType.substring(0, dataType.length()-1)+"N";    }
  )?
  {
    if(findKeyValue(currentTableName, dataType))    {
      addErrorMsg("Create table has failed: column definition is duplicated");
      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      currentTableName = "@TEMP";    }    else    {
      putKeyValue(currentTableName, columnName, dataType);    }  }
}

void tableConstraintDefinition(String tableName) :
{}
{
  primaryKeyConstraint(tableName)
| referentialConstraint(tableName)
}

void primaryKeyConstraint(String tableName) :
{
  String columnNameList;
  String databaseName;
}
{
  < PRIMARY_KEY >
  columnNameList = columnNameList()
  {
    if(findKeyValue(currentTableName, "@PK"))
    {
      addErrorMsg("Create table has failed: primary key definition is duplicated");
      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      currentTableName = "@TEMP";    }
    else
    {
      if(keyListValidation(currentTableName, columnNameList, true))
      {
        putKeyValue(currentTableName, "@PK", columnNameList);      }
      else
      {
      	myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      	currentTableName = "@TEMP";      }    }  }
}

void referentialConstraint(String referencingTableName) :
{
  String referencingColumnNameList;
  String referencedTableName;
  String referencedColumnNameList;
  String databaseName;
}
{
  < FOREIGN_KEY >
  referencingColumnNameList = columnNameList()
  { 
    if(!keyListValidation(currentTableName, referencingColumnNameList, true))
    {
      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      currentTableName = "@TEMP";    }  }
  < REFERENCES >
  referencedTableName = tableName()
  {
    if(!findKeyValue("@TABLELIST", referencedTableName))    {
      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      addErrorMsg("Create table has failed: foreign key references non existing table");
      currentTableName = "@TEMP";    }  }
  referencedColumnNameList = columnNameList()
  {
    if(!keyListValidation(referencedTableName, referencedColumnNameList, false))
    {
      addErrorMsg("Create table has failed: foreign key references non existing column");
      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      currentTableName = "@TEMP";    }
    if(!foreignKeyValidation(referencedTableName, referencedColumnNameList))
    {
      addErrorMsg("Create table has failed: foreign key references non primary key column");
      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      currentTableName = "@TEMP";    }  }
}

String columnNameList() :
{
  String columnNameList;
  String columnName;
}
{
  < LEFT_PAREN >
  columnNameList = columnName()
  (
    < COMMA >
    columnName = columnName()
    {
      columnNameList += (" "+columnName);    }
  )*
  < RIGHT_PAREN >
  {
    return columnNameList;  }
}

String dataType() :
{
  Token intValueToken;
  int intValue;
}
{
  < INT >
  {
    return "int 0";  }
| (
    < CHAR >
    < LEFT_PAREN >
	intValueToken = < INT_VALUE >
    < RIGHT_PAREN >
    {
      intValue = Integer.parseInt(intValueToken.image);
      if(intValue<1)      {
        addErrorMsg("Char length should be > 0");
      	myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");
      	currentTableName = "@TEMP";      }
      return ("char "+intValue);    }
  )
| < DATE >
  {
    return "date 0";  }
}

String tableName() :
{
  Token tableName;
}
{
  tableName=< LEGAL_IDENTIFIER >
  {
    return tableName.image;  }
}

String columnName() :
{
  Token columnName;
}
{
  columnName=< LEGAL_IDENTIFIER >
  {
    return columnName.image;  }
}

void descQuery() :
{
  String tableName;
}
{
  < DESC >
  tableName = tableName()
  {
    descTable(tableName);  }}
