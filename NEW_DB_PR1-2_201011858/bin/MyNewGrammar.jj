options{  static = true;  DEBUG_PARSER = false;}PARSER_BEGIN(SimpleDBMSParser)import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Arrays;// Import libraries from Berkeley DB
import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.Cursor;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;public class SimpleDBMSParser{  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static String errorMsg;  public static String currentTableName;  public static EnvironmentConfig envConfig;  public static Environment myDbEnvironment = null;  public static DatabaseConfig dbConfig;  public static Database myDatabase = null;  public static void main(String args []) throws ParseException  {    /* OPENING DB Environment */    // Open Database Environment or if not, create one.
    envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDbEnvironment = new Environment(new File("db/"), envConfig);        // Set database configuration
    dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(false);    /* DB Setting Finished */        SimpleDBMSParser parser = new SimpleDBMSParser(System.in);        while (true)    {      try      {        System.out.print("DB_2010-11858> ");        parser.command();      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }  }  public static void printMessage(int q)  {    switch (q)    {      case PRINT_SYNTAX_ERROR :      	// query processing 도중에 syntax error가 발생한 경우, currentTableName이 저장되어 있는 상태다.      	// 무효한 table이므로 remove 해주고, syntax error 메시지를 출력한다.      	if (!currentTableName.equals(""))      	{      	  myDbEnvironment.removeDatabase(null, currentTableName);      	}      	System.out.println("Syntax error");      	break;      case PRINT_CREATE_TABLE :      	// errorMsg가 공란이 아니라는 것은, create table query의 grammar는 맞았지만 semantic 오류가 있다는 뜻이다.      	// semantic 오류가 있었다면, table 이름은 @TEMP로 rename 되어있을 것이다.      	// 그러므로 @TEMP 이름의 table을 remove 해준다.         	if (errorMsg.equals(""))      	{      	        	  putKeyValue("@TABLELIST", currentTableName, currentTableName);      	  System.out.println("\'" + currentTableName + "\' table is created");      	}      	else      	{      	  System.out.println(errorMsg);      	  myDbEnvironment.removeDatabase(null, "@TEMP");      	}      	break;      case PRINT_DROP_TABLE :       	break;      case PRINT_DESC :       	break;    }  }  // dbName의 database를 열어서, keyString을 key로 하는 key-value pair가 있는지를 True/False로 반환한다.  static public boolean findKeyValue(String dbName, String keyString)  {    Cursor cursor = null;        myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry foundKey;    DatabaseEntry foundValue;    boolean result = false;    try    {      foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));      foundValue = new DatabaseEntry();      if (cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS)      {        result = true;      }      else      {        result = false;      }    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();    return result;  }  // dbName의 database에 <keyString, valueString >의 pair를 넣는다.  static public void putKeyValue(String dbName, String keyString, String valueString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);        DatabaseEntry key;    DatabaseEntry value;        try    {      key = new DatabaseEntry(keyString.getBytes("UTF-8"));      value = new DatabaseEntry(valueString.getBytes("UTF-8"));      cursor.put(key, value);    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();  }  // dbName의 테이블에서, keyString으로 key-value pair를 찾아 value를 반환한다.  static public String getValue(String dbName, String keyString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);        DatabaseEntry foundKey;    DatabaseEntry foundValue;        String result = "";    try    {      foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));      foundValue = new DatabaseEntry();      if (cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS)      {        result = new String(foundValue.getData(), "UTF-8");      }      else      {        result = "";      }    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();    return result;  }  // dbName의 database를 열어서, keyString으로 key-value pair를 찾고 해당 pair를 삭제한다.  static public void deleteKeyValue(String dbName, String keyString)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);        DatabaseEntry foundKey;    DatabaseEntry foundValue;        try    {      foundKey = new DatabaseEntry(keyString.getBytes("UTF-8"));      foundValue = new DatabaseEntry();      if (cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS)      {        cursor.delete();      }    }    catch (DatabaseException de)    {      de.printStackTrace();    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    cursor.close();    myDatabase.close();  }  // keyList로 받은 String은 여러 String 들이 " "로 구분되어있는 String 이다.  // keyArray의 원소들 중, dbName 이름의 database에 존재하지 않은 key가 있는지 찾는다.  // 하나라도 존재하지 않으면 false를 반환한다.   static public boolean keyListValidation(String dbName, String keyList, boolean addMsg)  {    String key;    String [] keyArray = keyList.split(" ");    int keyArrayLength = keyArray.length;    boolean result = true;    for (int i = 0; i < keyArrayLength; i++)    {      key = keyArray [i];      if (!findKeyValue(dbName, key))      {        result = false;        if (addMsg) addErrorMsg("Create table has failed: \'" + key + "\' does not exists in column definition");        break;      }    }    return result;  }  // explicit한 primary key / foreign key 정의가 없을 때, table을 규격에 맞추기 위해 호출한다.  static public void setDefaultPkFk(String dbName)  {    if (!findKeyValue(dbName, "@PK"))    {      // create table query 내에 primary key 정의가 없는 경우이다.      Cursor cursor = null;      myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);      cursor = myDatabase.openCursor(null, null);      String totalKeyList = "";      DatabaseEntry foundKey = new DatabaseEntry();      DatabaseEntry foundValue = new DatabaseEntry();      cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);      do      {        // table의 모든 key 값들을 순회하며, attribute에 PRI 속성을 부여한다.         try        {          String keyString = new String(foundKey.getData(), "UTF-8");          String valueString = new String(foundValue.getData(), "UTF-8");          // key 값들 중 @PK, @REFER, @REFERED 같은 애들은 건드리지 않기 위해 첫글자와 @를 비교한다.          if(!keyString.substring(0,1).equals("@"))          {            String[] valueArray = valueString.split(" ");            // Attribute의 key-value pair에서 value는 "TYPE SIZE NULL ..." 의 양식을 따르므로,            // Split 후 3번째 원소가 nullable에 대한 Y/N 값이다.            // Primary key 를 이루는 attribute이므로 N으로 설정한다.            valueArray[2] = "N";            // 새로운 value string 을 newValueString 이라는 이름으로 만든다.            String newValueString = "";            for(int j=0;j<valueArray.length;j++)            {              newValueString += (valueArray[j]+" ");            }            // 끝에 "PRI"를 붙인다.            newValueString += "PRI";            // foundValue DatabaseEntry를 수정하고, table에 put.            foundValue.setData(newValueString.getBytes());            cursor.put(foundKey, foundValue);            totalKeyList += (keyString + " ");          }        }        catch (UnsupportedEncodingException e)        {          e.printStackTrace();        }      }      while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);      // @PK 값에는 primary key를 이루는 attribute set이 "attr1 attr2 ... attrn"처럼 " "으로 구분되어 합쳐져있다.      // 이를 @PK 를 key 로 하는 pair를 만들어 table에 넣는다.      totalKeyList = totalKeyList.substring(0, totalKeyList.length() - 1);      cursor.close();      myDatabase.close();      putKeyValue(dbName, "@PK", totalKeyList);    }    // @REFER, @REFERED 의 값이 없다면 만들어준다.    if(!findKeyValue(dbName,"@REFER")) putKeyValue(dbName, "@REFER", "");    putKeyValue(dbName, "@REFERED", "");  }  // 참조받는 Table의 primary key와 참조하는 column set이 일치해야한다.  // String array comparison을 이용해서 쉽게 구현.  static public boolean referencePkValidation(String dbName, String keyList)  {    boolean result = false;    String primaryKey = getValue(dbName, "@PK");    String [] primaryKeyArray = primaryKey.split(" ");    String [] keyArray = keyList.split(" ");    if (keyArray.length == primaryKeyArray.length)    {      // 정확한 비교를 위해 우선 sorting      Arrays.sort(keyArray);      Arrays.sort(primaryKeyArray);      if (Arrays.equals(keyArray, primaryKeyArray)) result = true;    }    return result;  }  // 참조받는 column set과 참조하는 column set의 type 및 size가 일치하는지 확인한다.  // 일치하면 true, 아니면 false를 반환한다.  static public boolean referenceDataTypeValidation(String dbName1, String keyList1, String dbName2, String keyList2)  {    boolean result = true;    String [] keyArray1 = keyList1.split(" ");    String [] keyArray2 = keyList2.split(" ");    // 우선 column set의 크기가 같아야 한다.    if (keyArray1.length == keyArray2.length)    {      for (int i = 0; i < keyArray1.length; i++)      {        // "TYPE SIZE ..."로 구성되므로, [0]: int/char/date [1]: size        // 두 가지를 체크해준다.        String [] attrDataType1 = getValue(dbName1, keyArray1 [i]).split(" ");        String [] attrDataType2 = getValue(dbName2, keyArray2 [i]).split(" ");        boolean typeMatch = attrDataType1 [0].equals(attrDataType2 [0]);        boolean sizeMatch = attrDataType1 [1].equals(attrDataType2 [1]);        if (!(typeMatch && sizeMatch))        {          result = false;          break;        }      }    }    else    {      result = false;    }    return result;  }  // explicit 한 primary key declaration이 있는 경우에는,  // 해당 columns 들은 무조건 not nullable 로 지정하고,   // 해당 columns 들만 "PRI" 속성을 부여하기 위해 value 값에 뒤에 "PRI"를 덧붙인다.  static public void addPrimaryKey(String dbName, String columnNameList)  {    String[] columnNameArray = columnNameList.split(" ");    Arrays.sort(columnNameArray);        for(int i=0;i<columnNameArray.length;i++)    {      String valueString = getValue(dbName, columnNameArray[i]);      String[] valueArray = valueString.split(" ");      valueArray[2] = "N";      valueString="";      for(int j=0;j<valueArray.length;j++)      {        valueString += (valueArray[j]+" ");      }      valueString += "PRI";      putKeyValue(dbName, columnNameArray[i], valueString);     }        putKeyValue(dbName, "@PK", columnNameList);  }  // reference 가 declaration된 경우,  // 참조하는 columns들의 key-value pair에서 value 뒤에 "FOR"을 덧붙이고,  // 참조하는 table의 @REFER key 값의 value를 갱신하고,  // 참조받는 table의 @REFERED key 값의 value를 갱신한다.  static public void addForeignKey(String referencingTable, String columnNameList, String referencedTable)  {    String currentRefered = getValue(referencedTable, "@REFERED");    currentRefered += (referencingTable+" ");    putKeyValue(referencedTable, "@REFERED", currentRefered);    String currentRefer = getValue(referencingTable, "@REFER");    currentRefer += (referencedTable+" ");    putKeyValue(referencingTable, "@REFER", currentRefer);        String[] columnNameArray = columnNameList.split(" ");    for(int i=0;i<columnNameArray.length;i++)    {      String currentDataType = getValue(referencingTable, columnNameArray[i]);      String updatedDataType = currentDataType + " FOR";      putKeyValue(referencingTable, columnNameArray[i], updatedDataType);    }  }  // table1, table2, table3 ...로 요청된 table list들의 desc를 수행한다.  // * 이 요청된 경우 모두 출력해주고,  // table1, table2, ... 로 요청된 경우 우선 존재하는 table인지를 체크하고 모두 존재한다면 출력한다.  static public void descTableList(String dbNameList)  {    if(dbNameList.equals("*"))    {      // totalTableList: "table1 table2 table3 ..."      String totalTableList = getValue("@TABLELIST", "@ALL");      if (!totalTableList.equals(""))      {        String [] totalTableArray = totalTableList.split(" ");        System.out.println("---------------------------------------------");        for (int i = 0; i < totalTableArray.length; i++)        {          descTable(totalTableArray[i]);        }      }    }    else    {      String [] dbNameArray = dbNameList.split(" ");      boolean isError = false;      for (int i = 0; i < dbNameArray.length; i++)      {        // @TABLELIST에 존재하는 key 값이 아니라는 얘기는, 존재하지 않는 table이라는 의미이므로 error 발생이다.        if (!findKeyValue("@TABLELIST", dbNameArray [i]))        {          isError = true;          break;        }      }      if (!isError)      {        System.out.println("---------------------------------------------");        for (int i = 0; i < dbNameArray.length; i++)        {          descTable(dbNameArray [i]);        }      }      else      {        System.out.println("No such table");      }    }  }  // 단일 table 출력을 담당.  // destTableList에서 호출된다.  static public void descTable(String dbName)  {    Cursor cursor = null;    myDatabase = myDbEnvironment.openDatabase(null, dbName, dbConfig);    cursor = myDatabase.openCursor(null, null);    DatabaseEntry foundKey = new DatabaseEntry();    DatabaseEntry foundValue = new DatabaseEntry();    // table에는 @PK, @REFER, @REFERED 의 key를 가지고 있다.    // key들이 alphabetically ordered 되어있으므로, 첫 3개가 쟤네들에 해당.    // 그러므로 desc 에서 저 3개를 건너뛰고 시작한다.    cursor.getFirst(foundKey, foundValue, LockMode.DEFAULT);    cursor.getNext(foundKey, foundValue, LockMode.DEFAULT);    cursor.getNext(foundKey, foundValue, LockMode.DEFAULT);    cursor.getNext(foundKey, foundValue, LockMode.DEFAULT);    System.out.println("table_name ["+dbName+"]");    System.out.println("column_name\ttype\tnull\tkey");        do    {      try      {        String keyString = new String(foundKey.getData(), "UTF-8");        String valueString = new String(foundValue.getData(), "UTF-8");        String[] valueArray = valueString.split(" ");        // char인 경우 size가 의미가 있고,        // int / date의 경우 그냥 size를 0으로 해놨고 의미가 없으니 안써야한다.        if(valueArray[0].equals("char"))        {          System.out.print(keyString+"\tchar("+valueArray[1]+")\t"+valueArray[2]+"\t");        }        else        {          System.out.print(keyString+"\t"+valueArray[0]+"\t"+valueArray[2]+"\t");        }        switch (valueArray.length)        {          // 아무 key도 아님          case 3 :          	System.out.println("");          	break;          // PRI or FOR          case 4 :          	System.out.println(valueArray[3]);          	break;          // PRI and FOR          case 5 :          	System.out.println(valueArray[3]+"\t"+valueArray[4]);          	break;        }      }      catch (UnsupportedEncodingException e)      {        e.printStackTrace();      }    } while (cursor.getNext(foundKey, foundValue, LockMode.DEFAULT) == OperationStatus.SUCCESS);    System.out.println("---------------------------------------------");        cursor.close();    myDatabase.close();  }  static public void dropTable(String dbName)  {    if (dbName.equals("*"))    {      String totalTableList = getValue("@TABLELIST", "@ALL");      if(!totalTableList.equals(""))      {        String [] totalTableArray = totalTableList.split(" ");        for (int i = 0; i < totalTableArray.length; i++)        {          myDbEnvironment.removeDatabase(null, totalTableArray [i]);        }        myDbEnvironment.removeDatabase(null, "@TABLELIST");      }      System.out.println("Every table is dropped");    }    else    {      String [] dbNameArray = dbName.split(" ");      for (int i = 0; i < dbNameArray.length; i++)      {        if (findKeyValue("@TABLELIST", dbNameArray [i]))        {          // @REFERED 는 자신을 참조하는 Table 정보.          // 그러므로 @REFERED가 ""가 아니고 값이 있으면 drop 하지말아야 한다.          if (!getValue(dbNameArray [i], "@REFERED").equals(""))          {            System.out.println("Drop table has failed: '" + dbNameArray [i] + "'is referenced by other table");          }          else          {            // @REFER는 내가 참조하는 테이블 정보.            // 그러므로 나를 Drop table 하면서, 내가 참조하는 테이블들의 @REFERED 에서 내 이름을 뺀다.            if(!getValue(dbNameArray[i], "@REFER").equals(""))            {              String referedList = getValue(dbNameArray[i], "@REFER");              String[] referedArray = referedList.split(" ");              for(int j=0;j<referedArray.length;j++)              {                // "table1 table2 ... tablen" 에서 table2를 지워 "table1 ... tablen" 으로 만드는 것같은 상황을 처리.                deletePartialValue(referedArray[j], "@REFERED", dbNameArray[i]);              }            }                        myDbEnvironment.removeDatabase(null, dbNameArray [i]);            // @TABLELIST 에서 <tablename, "column1 column2 ... columnn" > pair를 삭제                        deleteKeyValue("@TABLELIST", dbNameArray [i]);            // @TABLELIST 의 @ALL 값이 "table1 table2 table3 ..." 인데,            // drop한 table을 빼준다.            deletePartialValue("@TABLELIST", "@ALL", dbNameArray[i]);                        System.out.println("'" + dbNameArray [i] + "' table is dropped");          }        }        else        {          System.out.println("No such table named '" + dbNameArray [i] + "'");        }      }    }  }  static public void addErrorMsg(String msg)  {    // 첫 error messsge만 출력하기 위함.    if (errorMsg.equals(""))    {      errorMsg = msg;    }  }  static public void addTableName(String tableName)  {    if(!tableName.equals("@TEMP"))    {      // @ALL 뒤에 table name을 덧붙인다.      String currentTableNameList = getValue("@TABLELIST","@ALL");      String newTableNameList = currentTableNameList+tableName+" ";      putKeyValue("@TABLELIST", "@ALL", newTableNameList);    }  }  // "value1 value2 value3 ..." 에서 value2를 지운다면 "value1 value3 ..."가 된다.  // 해당 작업을 위한 함수.  static public void deletePartialValue(String dbName, String keyString, String valueToDelete)  {    String valueList = getValue(dbName, keyString);    String[] valueArray = valueList.split(" ");        int i;    for(i=0;i<valueArray.length;i++)    {      if(valueArray[i].equals(valueToDelete)) break;    }    if(i!=valueArray.length)    {      valueArray[i] = "";      String newValueList = "";      for (int j = 0; j < valueArray.length; j++)      {        newValueList += (valueArray[j] + " ");      }      newValueList = newValueList.substring(0, newValueList.length() - 1);      putKeyValue(dbName, keyString, newValueList);    }  }}PARSER_END(SimpleDBMSParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >}TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < SIGN :    "+"  | "-" >| < STAR : "*" >| < INT_VALUE : (< SIGN >)? ([ "0"-"9" ])+ >| < LEGAL_IDENTIFIER :    < ALPHABET >    (      < ALPHABET >    | < UNDERSCORE >    )* >| < ALPHABET : [ "A"-"Z", "a"-"z" ] >}void command() :{}{  queryList()|  (    < EXIT >     < SEMICOLON >    {      if (myDatabase != null) myDatabase.close();      if (myDbEnvironment != null) myDbEnvironment.close();      System.exit(0);    }  )}void queryList() :{  int q;}{  (    q = query()     < SEMICOLON >    {      System.out.print("DB_2010-11858> ");      printMessage(q);    }  )+}int query() :{  int q;  currentTableName = "";}{  (    createTableQuery()    {      q = PRINT_CREATE_TABLE;    }  | dropTableQuery()    {      q = PRINT_DROP_TABLE;    }  | descQuery()    {      q = PRINT_DESC;    }  )  (    {      return q;    }  )}void createTableQuery() :{  String tableName;}{  < CREATE_TABLE >   tableName = tableName()  {    errorMsg = "";    // @TABLELIST에 존재하는 key라는 것은 이미 tableNAME의 table이 존재한다는 것    if (findKeyValue("@TABLELIST", tableName))    {      addErrorMsg("Create table has failed: table with the same name already exists");      currentTableName = "@TEMP";    }    else    {      currentTableName = tableName;    }  }  tableElementList(tableName)  {    // create table query의 grammar가 모두 지켜진 경우 해당 작업을 수행한다.    setDefaultPkFk(currentTableName);    addTableName(currentTableName);  }}void tableElementList(String tableName) :{}{  < LEFT_PAREN >   tableElement(tableName)  (    < COMMA >     tableElement(tableName)  )*  < RIGHT_PAREN >}void tableElement(String tableName) :{}{  columnDefinition(tableName)| tableConstraintDefinition(tableName)}void columnDefinition(String tableName) :{  String columnName;  String dataType;  String databaseName;  boolean result;}{  columnName = columnName()   dataType = dataType()  {    // example: "int 0 Y" "char 10 Y"    dataType += " Y";  }  (    < NOT_NULL >    {      // example: "int 0 N" "char 10 N"       dataType = dataType.substring(0, dataType.length() - 1) + "N";    }  )?  {    // table에 이미 선언된 columnName인지 확인한다.    if (findKeyValue(currentTableName, columnName))    {      addErrorMsg("Create table has failed: column definition is duplicated");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    else    {      putKeyValue(currentTableName, columnName, dataType);    }  }}void tableConstraintDefinition(String tableName) :{}{  primaryKeyConstraint(tableName)| referentialConstraint(tableName)}void primaryKeyConstraint(String tableName) :{  String columnNameList;  String databaseName;}{  < PRIMARY_KEY >   columnNameList = columnNameList()  {    // primary key 정의가 이미 있었다면, @PK 를 key로 하는 pair가 존재할 것.    if (findKeyValue(currentTableName, "@PK"))    {      addErrorMsg("Create table has failed: primary key definition is duplicated");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    else    {      // 정의된 columns들 가지고 primary key를 구성했는지 체크한다.      if (keyListValidation(currentTableName, columnNameList, true))      {        addPrimaryKey(currentTableName, columnNameList);      }      else      {        myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");        currentTableName = "@TEMP";      }    }  }}void referentialConstraint(String referencingTableName) :{  String referencingColumnNameList;  String referencedTableName;  String referencedColumnNameList;  String databaseName;}{  < FOREIGN_KEY >   referencingColumnNameList = columnNameList()  {    // 존재하는 columns 들 가지고 Foreign key를 구성했는지 체크한다.    if (!keyListValidation(currentTableName, referencingColumnNameList, true))    {      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }  }  < REFERENCES >   referencedTableName = tableName()  {    // 참조하려는 table이 존재하는 table인지 확인한다.    if (!findKeyValue("@TABLELIST", referencedTableName))    {      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      addErrorMsg("Create table has failed: foreign key references non existing table");      currentTableName = "@TEMP";    }  }  referencedColumnNameList = columnNameList()  {    // 참조받을 columns들이 참조받을 table에 존재하는 columns들인가?    if (!keyListValidation(referencedTableName, referencedColumnNameList, false))    {      addErrorMsg("Create table has failed: foreign key references non existing column");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    // 참조받을 columns들이 primary key를 구성하는가?    else if (!referencePkValidation(referencedTableName, referencedColumnNameList))    {      addErrorMsg("Create table has failed: foreign key references non primary key column");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    // 참조하려는 columns들과 참조받을 columns들의 type이 일치하는가?    else if (!referenceDataTypeValidation(currentTableName, referencingColumnNameList, referencedTableName, referencedColumnNameList))    {      addErrorMsg("Create table has failed: foreign key references wrong type");      myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");      currentTableName = "@TEMP";    }    if (!currentTableName.equals("@TEMP"))    {      addForeignKey(currentTableName, referencingColumnNameList, referencedTableName);    }  }}String columnNameList() :{  String columnNameList;  String columnName;}{  < LEFT_PAREN >   columnNameList = columnName()  (    < COMMA >     columnName = columnName()    {      columnNameList += (" " + columnName);    }  )*  < RIGHT_PAREN >  {    return columnNameList;  }}String dataType() :{  Token intValueToken;  int intValue;}{  < INT >  {    return "int 0";  }|  (    < CHAR >     < LEFT_PAREN >     intValueToken = < INT_VALUE >     < RIGHT_PAREN >    {      intValue = Integer.parseInt(intValueToken.image);      if (intValue < 1)      {        // char(0), char(-1) 같은 경우 에러 발생        addErrorMsg("Char length should be > 0");        myDbEnvironment.renameDatabase(null, currentTableName, "@TEMP");        currentTableName = "@TEMP";      }      return ("char " + intValue);    }  )| < DATE >  {    return "date 0";  }}String tableNameList() :{  String tableNameList;  String tableName;}{  < STAR >  {    return "*";  }|  (    tableNameList = tableName()    (      < COMMA >       tableName = tableName()      {        tableNameList += (" " + tableName);      }    )*  )  {    return tableNameList;  }}String tableName() :{  Token tableName;}{  tableName = < LEGAL_IDENTIFIER >  {    return tableName.image.toLowerCase();  }}String columnName() :{  Token columnName;}{  columnName = < LEGAL_IDENTIFIER >  {    return columnName.image.toLowerCase();  }}void dropTableQuery() :{  String tableNameList;}{  < DROP_TABLE >  {    errorMsg = "";  }  tableNameList = tableNameList()  {    dropTable(tableNameList);  }}void descQuery() :{  String tableNameList;}{  < DESC >   tableNameList = tableNameList()  {    descTableList(tableNameList);  }}
